// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using DragonBones.Core;
using DragonBones.Display;
using DragonBones.Objects;
using Com.Viperstudio.Geom;
using System.Collections.Generic;
using Com.Viperstudio.Utils;

namespace DragonBones
{
	public class Slot :DBObject
	{
		/** @private */
		public List<DisplayData> _dislayDataList;
		/** @private */
		public IDisplayBridge _displayBridge;
		/** @private */
		public float _originZOrder;
		/** @private */
		public float _tweenZorder;
		/** @private */
		public bool _isDisplayOnStage;
		
		private bool _isHideDisplay;
		private float _offsetZOrder;
		private int _displayIndex;
		private string _blendMode;
		
		public float ZOrder {
				get { return _originZOrder + _tweenZorder + _offsetZOrder; }
				set 
				{
						if (ZOrder != value) {
								_offsetZOrder = value - _originZOrder - _tweenZorder;
								if (this._armature!=null) {
										this._armature._slotsZOrderChanged = true;
								}
						}
				}
		}

		public string BlendMode {
				get { return _blendMode; } 

			set {
						if (_blendMode != value) {
								_blendMode = value;
								if (_displayBridge.Display!=null) {
										_displayBridge.UpdateBlendMode (_blendMode);
								}
						}
				}

		}

	
		/**
		 * The DisplayObject belonging to this Bone instance. Instance type of this object varies from flash.display.DisplayObject to startling.display.DisplayObject and subclasses.
		 */
		public Object Display{

			get {
				Object display = _displayList[_displayIndex];
				if(display is Armature)
				{
					return (display as Armature).Display;
				}
				return display;
			}
			set {
				_displayList[_displayIndex] = value;
				setDisplay(value);
			}
		}


		
		/**
		 * The sub-armature of this Slot instance.
		 */
		public Armature ChildArmature {
				get {
						if (_displayList [_displayIndex] is Armature) {
								return _displayList [_displayIndex] as Armature;
						}
						return null;
				}
				set {

						_displayList [_displayIndex] = value;
						if (value!=null) {
								setDisplay (value.Display);
						}

				}
		}

			
	
		private List<Object> _displayList;
		/**
		 * The DisplayObject list belonging to this Slot instance.
		 */
		public List<Object> DisplayList
		{
			get {
				    return _displayList;
				}
			set {
				if(value == null)
				{
					throw new ArgumentException();
				}

				_displayList.Clear();
				for(int i=0;i<value.Count;i++)
				{
					_displayList.Add(value[i]);
				}

				if(_displayIndex >= 0)
				{
					int displayIndexBackup = _displayIndex;
					_displayIndex = -1;
					changeDisplay(displayIndexBackup);
				}
			}
		}
	
		
		private void setDisplay(Object display)
		{
			if(_displayBridge.Display!=null)
			{
				_displayBridge.Display = display;
			}
			else
			{
				_displayBridge.Display = display;
				if(this._armature!=null)
				{
					_displayBridge.AddDisplay(this._armature.Display, this.ZOrder);
					this._armature._slotsZOrderChanged = true;
				}
			}
			
			updateChildArmatureAnimation();
			
			if(!_isHideDisplay && _displayBridge.Display!=null)
			{
				_isDisplayOnStage = true;
				_displayBridge.UpdateBlendMode(_blendMode);
			}
			else
			{
				_isDisplayOnStage = false;
			}
		}
		
		/** @private */
		public void changeDisplay(int displayIndex)
		{
			if(displayIndex < 0)
			{
				if(!_isHideDisplay)
				{
					_isHideDisplay = true;
					_displayBridge.RemoveDisplay();
					updateChildArmatureAnimation();
				}
			}
			else
			{
				bool changeShowState = false;
				if(_isHideDisplay)
				{
					_isHideDisplay = false;
				    changeShowState = true;
					if(this._armature!=null)
					{
						_displayBridge.AddDisplay(this._armature.Display, this.ZOrder);
						this._armature._slotsZOrderChanged = true;
					}
				}
				
				uint length = (uint)_displayList.Count;
				if(displayIndex >= length && length > 0)
				{
					displayIndex = (int)length - 1;
				}
				if(_displayIndex != displayIndex)
				{
					_displayIndex = displayIndex;
					
					Object content = _displayList[_displayIndex];
					if(content is Armature)
					{
						setDisplay((content as Armature).Display);
					}
					else
					{
						setDisplay(content);
					}
					
					if(_dislayDataList!=null && _displayIndex <= _dislayDataList.Count)
					{
						this._origin.Copy(_dislayDataList[_displayIndex].Transform);
					}
				}
				else if(changeShowState)
				{
					updateChildArmatureAnimation();
				}
			}

			if(!_isHideDisplay && _displayBridge.Display!=null)
			{
				_isDisplayOnStage = true;
			}
			else
			{
				_isDisplayOnStage = false;
			}
		}
		
		/**
		 * @inheritDoc
		 */
		override public bool Visible
		{
			set{
					if (value != this._visible) {
						this._visible = value;
						updateVisible (this._visible);
					}
				}
		}
		
		/** @private */
		override public void setArmature(Armature value)
		{
			base.setArmature(value);
			if(this._armature!=null)
			{
				this._armature._slotsZOrderChanged = true;
				_displayBridge.AddDisplay(this._armature.Display, this.ZOrder);
			}
			else
			{
				_displayBridge.RemoveDisplay();
			}
		}
		
		public Slot(IDisplayBridge displayBrideg)
		{
			_displayBridge = displayBrideg;
			_displayList = new List<object>();
			_displayIndex = -1;
			_scaleType = 1;
			
			_originZOrder = 0;
			_tweenZorder = 0;
			_offsetZOrder = 0;
			
			_isDisplayOnStage = false;
			_isHideDisplay = false;
			
			_blendMode = "normal";
			if(_displayBridge.Display!=null)
			{
				_displayBridge.UpdateBlendMode(_blendMode);
			}
		}
		
		/**
		 * @inheritDoc
		 */
		override public void Dispose()
		{
			if(_displayBridge==null)
			{
				return;
			}
			base.Dispose();
			
			_displayBridge.Dispose();
			_displayList.Clear();
			
			_displayBridge = null;
			_displayList = null;
			_dislayDataList = null;
		}
		
		/** @private */
		override public void update()
		{
			base.update();
			
			if(_isDisplayOnStage)
			{
				float pivotX = _parent._tweenPivot.X;
				float pivotY = _parent._tweenPivot.Y;



				if(pivotX!=float.NaN || pivotY!=float.NaN)
				{


					Com.Viperstudio.Geom.Matrix parentMatrix = _parent._globalTransformMatrix;
					this._globalTransformMatrix.Tx += (parentMatrix.A * pivotX + parentMatrix.C * pivotY);
					this._globalTransformMatrix.Ty += (parentMatrix.B * pivotX + parentMatrix.D * pivotY);
				}
				
				_displayBridge.UpdateTransform(this._globalTransformMatrix, this._global);
			}
		}
		
		/** @private */
		public void updateVisible(bool value)
		{
			_displayBridge.Visible = this._parent.Visible && this._visible && value;
		}
		
		private void updateChildArmatureAnimation()
		{
			Armature childArmature = this.ChildArmature;
			
			if(childArmature!=null)
			{
				if(_isHideDisplay)
				{
					childArmature.Animation.Stop();
					childArmature.Animation._lastAnimationState = null;
				}
				else
				{
					if(
						this._armature!=null &&
						this._armature.Animation.LastAnimationState!=null &&
						childArmature.Animation.HasAnimation(this._armature.Animation.LastAnimationState.Name)
						)
					{
						childArmature.Animation.GotoAndPlay(this._armature.Animation.LastAnimationState.Name);
					}
					else
					{
						childArmature.Animation.Play();
					}
				}
			}
		}
		
		/**
		 * Change all DisplayObject attached to this Bone instance.
		 * @param	displayList An array of valid DisplayObject to attach to this Bone.
		 */
		public void ChangeDisplayList(List<Object> displayList)
		{
			this.DisplayList = displayList;
		}
	}
}

