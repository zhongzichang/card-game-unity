// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using Com.Viperstudio.Utils;
using DragonBones.Utils;
using DragonBones.Core;
using Com.Viperstudio.Geom;

namespace DragonBones.Objects
{
	public class ObjectDataParser
	{

		private delegate Object Function(Dictionary<string, Object> frameObject, uint frameRate);
		
		public static SkeletonData ParseSkeletonData(Dictionary<string, Object> rawData)
		{
			if(rawData == null)
			{
				throw new ArgumentException();
			}
			
			string version = rawData[ConstValues.A_VERSION].ToString();

			switch (version)
			{
			case DragonBones.Core.DragonBones.DATA_VERSION:
				break;
			default:
				throw new Exception("Nonsupport version!");
			}
			
			uint frameRate =  uint.Parse(rawData[ConstValues.A_FRAME_RATE].ToString());

			SkeletonData data = new SkeletonData();
			data.Name = rawData[ConstValues.A_NAME] as String;

			foreach(Dictionary<String, Object> armatureObject in rawData[ConstValues.ARMATURE] as List<Object>)
			{

				data.AddArmatureData(parseArmatureData(armatureObject as Dictionary<string, object>, data, frameRate));
			}

			return data;
		}
		
		private static ArmatureData parseArmatureData(Dictionary<String, Object> armatureObject, SkeletonData data, uint frameRate)
		{
			ArmatureData armatureData = new ArmatureData();
			armatureData.Name = armatureObject[ConstValues.A_NAME] as String;

			//Logger.Log("ObjectDataParser::: " + armatureObject[ConstValues.BONE].ToString());
			foreach(Dictionary<String, Object> boneObject in armatureObject[ConstValues.BONE] as List<object>)
			{

				armatureData.AddBoneData(parseBoneData(boneObject as Dictionary<string, object>));
			}
			
			foreach(Dictionary<String, Object> skinObject in armatureObject[ConstValues.SKIN] as List<object>)
			{
				armatureData.AddSkinData(parseSkinData(skinObject as Dictionary<string, object>, data));
			}
			
			DBDataUtil.TransformArmatureData(armatureData);
			armatureData.SortBoneDataList();
			
			foreach(Dictionary<String, Object> animationObject in armatureObject[ConstValues.ANIMATION] as List<object>)
			{
				armatureData.AddAnimationData(parseAnimationData(animationObject as Dictionary<string, object>, armatureData, frameRate));
			}
			
			return armatureData;
		}
		
		private static BoneData parseBoneData(Dictionary<String, Object> boneObject)
		{
			BoneData boneData = new BoneData();
			boneData.Name = boneObject[ConstValues.A_NAME] as String;
			if (boneObject.ContainsKey (ConstValues.A_PARENT)) {
				boneData.Parent = boneObject [ConstValues.A_PARENT] as string;
			}
			if (boneObject.ContainsKey (ConstValues.A_LENGTH)) {
				boneData.Length = boneObject [ConstValues.A_LENGTH] == null ? 0 : (int)boneObject [ConstValues.A_LENGTH];
			}


			if (boneObject.ContainsKey (ConstValues.A_SCALE_MODE)) {
				Object scaleModeObj = boneObject[ConstValues.A_SCALE_MODE];
			   if (scaleModeObj != null) 
				{
					int scaleMode = int.Parse(scaleModeObj.ToString());
					boneData.ScaleMode = scaleMode;
				}
			}
			if(boneObject.ContainsKey (ConstValues.A_FIXED_ROTATION))
			{
		     	bool inheritRotation = bool.Parse(boneObject[ConstValues.A_FIXED_ROTATION].ToString ());
			    if (inheritRotation)
			     {
				   boneData.FixedRotation = inheritRotation;
			     }
			}
			parseTransform(boneObject[ConstValues.TRANSFORM] as Dictionary<string, object>, boneData.Global);
			boneData.Transform.Copy(boneData.Global);

			//Logger.Log (boneData.Name + " " +  boneData.Transform.X + " " + boneData.Transform.Y);
			
			return boneData;
		}
		
		private static SkinData parseSkinData(Dictionary<String, Object> skinObject, SkeletonData data)
		{
			SkinData skinData = new SkinData();
			skinData.Name = skinObject[ConstValues.A_NAME] as String;
			
			foreach(Dictionary<String, Object> slotObject in skinObject[ConstValues.SLOT] as List<object>)
			{
				skinData.AddSlotData(parseSlotData(slotObject as Dictionary<string, object>, data));
			}
			
			return skinData;
		}
		
		private static SlotData parseSlotData(Dictionary<String, Object> slotObject, SkeletonData data)
		{
			SlotData slotData = new SlotData();
			slotData.Name = slotObject[ConstValues.A_NAME] as String;
			slotData.Parent = slotObject[ConstValues.A_PARENT] as String;
			slotData.ZOrder = (float)slotObject[ConstValues.A_Z_ORDER];

			if (slotObject.ContainsKey (ConstValues.A_BLENDMODE)) {
			  
			  if (slotObject [ConstValues.A_BLENDMODE] == null) 
			  {
				slotData.BlendMode = "normal";
			  }
			  else
			  {
				slotData.BlendMode = slotObject [ConstValues.A_BLENDMODE].ToString();
			  }
			}
			foreach(Dictionary<String, Object> displayObject in slotObject[ConstValues.DISPLAY] as List<object>)
			{
				slotData.AddDisplayData(parseDisplayData(displayObject as Dictionary<string, object>, data));
			}
			
			return slotData;
		}
		
		private static DisplayData parseDisplayData(Dictionary<String, Object> displayObject, SkeletonData data)
		{
			DisplayData displayData = new DisplayData();
			displayData.Name = displayObject[ConstValues.A_NAME] as String;
			displayData.Type = displayObject[ConstValues.A_TYPE] as String;
			
			displayData.Pivot = data.AddSubTexturePivot(
				0, 
				0, 
				displayData.Name
				);
			
			parseTransform(displayObject[ConstValues.TRANSFORM] as Dictionary<String, object>, displayData.Transform, displayData.Pivot);
			
			return displayData;
		}
		
		private static AnimationData parseAnimationData(Dictionary<String, Object> animationObject, ArmatureData armatureData, uint frameRate)
		{
			AnimationData animationData = new AnimationData();
			animationData.Name = animationObject[ConstValues.A_NAME] as String;
			animationData.FrameRate = (uint)frameRate;

			animationData.Loop = int.Parse(animationObject[ConstValues.A_LOOP].ToString());
			animationData.FadeInTime = (float)animationObject[ConstValues.A_FADE_IN_TIME];
			animationData.Duration = (float)animationObject [ConstValues.A_DURATION] /frameRate;
			animationData.Scale = (float)animationObject[ConstValues.A_SCALE];
			
			if(animationObject.ContainsKey(ConstValues.A_TWEEN_EASING))
			{
				Object tweenEase = animationObject[ConstValues.A_TWEEN_EASING];
				if(
					tweenEase == null
					)
				{
					animationData.TweenEasing = float.NaN;
				}
				else
				{
					animationData.TweenEasing = (float)tweenEase;
				}
			}
			else
			{
				animationData.TweenEasing = float.NaN;
			}
			
			parseTimeline(animationObject as Dictionary<string, object>, animationData, parseMainFrame, frameRate);
			
			TransformTimeline timeline;
			string timelineName;
			foreach(Dictionary<String, Object> timelineObject in animationObject[ConstValues.TIMELINE] as List<object>)
			{
				timeline = parseTransformTimeline(timelineObject as Dictionary<string, object>, animationData.Duration, frameRate);
				timelineName = (timelineObject as Dictionary<string, object>)[ConstValues.A_NAME] as String;
				animationData.AddTimeline(timeline, timelineName);
			}
			
			DBDataUtil.AddHideTimeline(animationData, armatureData);
			DBDataUtil.TransformAnimationData(animationData, armatureData);
			
			return animationData;
		}
		
		private static void parseTimeline(Dictionary<String, Object> timelineObject, Timeline timeline, Function frameParser, uint frameRate)
		{

			if(timelineObject.ContainsKey(ConstValues.FRAME))
			{
				float position = 0f;
				Frame frame = null;

				foreach(Dictionary<String, Object> frameObject in timelineObject[ConstValues.FRAME] as List<object>)
				{
					frame = frameParser(frameObject as Dictionary<string, object>, frameRate) as Frame;
					frame.Position = position;
					timeline.AddFrame(frame);
					position += frame.Duration;
				}
				if(frame!=null)
				{
					frame.Duration = timeline.Duration - frame.Position;
				}

			}

		
		}
		
		private static TransformTimeline parseTransformTimeline(Dictionary<String, Object> timelineObject, float duration, uint frameRate)
		{
			TransformTimeline timeline = new TransformTimeline();
			timeline.Duration = duration;
			
			parseTimeline(timelineObject, timeline, parseTransformFrame, frameRate);
			
			timeline.Scale = (float)timelineObject[ConstValues.A_SCALE];
			timeline.Offset = (float)timelineObject[ConstValues.A_OFFSET];
			
			return timeline;
		}
		
		private static void parseFrame(Dictionary<String, Object> frameObject, Frame frame, uint frameRate)
		{
			frame.Duration = (float)frameObject[ConstValues.A_DURATION] / frameRate;
			if(frameObject.ContainsKey(ConstValues.A_ACTION))
			    frame.Action = frameObject[ConstValues.A_ACTION] as String;
			if(frameObject.ContainsKey(ConstValues.A_EVENT))
			    frame.Evt = frameObject[ConstValues.A_EVENT] as String;
			if(frameObject.ContainsKey(ConstValues.A_SOUND))
			    frame.Sound = frameObject[ConstValues.A_SOUND] as String;
		}
		
		private static Frame parseMainFrame(Dictionary<String, Object> frameObject, uint frameRate)
		{
			Frame frame = new Frame();
			parseFrame(frameObject, frame, frameRate);
			return frame;
		}
		
		private static TransformFrame parseTransformFrame(Dictionary<String, Object> frameObject, uint frameRate)
		{
			TransformFrame frame = new TransformFrame();
			parseFrame(frameObject, frame, frameRate);

			if(frameObject.ContainsKey(ConstValues.A_HIDE))
			{
				frame.Visible = (uint)frameObject[ConstValues.A_HIDE] != 1;
			}
			else
			{
				frame.Visible = true;
			}

			
			if(frameObject.ContainsKey(ConstValues.A_TWEEN_EASING ))
			{
				Object tweenEase = frameObject[ConstValues.A_TWEEN_EASING];
				if(
					tweenEase == null
					)
				{
					frame.TweenEasing = float.NaN;
				}
				else
				{
					frame.TweenEasing = (float)tweenEase;
				}
			}
			else
			{
				frame.TweenEasing = 0f;
			}

			if(frameObject.ContainsKey(ConstValues.A_TWEEN_ROTATE))
			{
				frame.TweenRotate = (int)frameObject[ConstValues.A_TWEEN_ROTATE];
			}
			   
			if(frameObject.ContainsKey(ConstValues.A_DISPLAY_INDEX))
			{

				frame.DisplayIndex = int.Parse(frameObject[ConstValues.A_DISPLAY_INDEX].ToString());

			}
			     


			if(frameObject.ContainsKey(ConstValues.A_Z_ORDER))
			     frame.ZOrder = (float)frameObject[ConstValues.A_Z_ORDER];
			if(frameObject.ContainsKey(ConstValues.TRANSFORM))
				 parseTransform(frameObject[ConstValues.TRANSFORM] as Dictionary<string, object>, frame.Global, frame.Pivot);

			frame.Transform.Copy(frame.Global);
			Dictionary<String, Object> colorTransformObject = null;
			if(frameObject.ContainsKey(ConstValues.COLOR_TRANSFORM))
			   colorTransformObject = frameObject[ConstValues.COLOR_TRANSFORM] as Dictionary<string, object>;

			if(colorTransformObject!=null)
			{
				frame.Color = new ColorTransform();
				frame.Color.AlphaOffset = (float)colorTransformObject[ConstValues.A_ALPHA_OFFSET];
				frame.Color.RedOffset = (float)colorTransformObject[ConstValues.A_RED_OFFSET];
				frame.Color.GreenOffset = (float)colorTransformObject[ConstValues.A_GREEN_OFFSET];
				frame.Color.BlueOffset = (float)colorTransformObject[ConstValues.A_BLUE_OFFSET];

				frame.Color.AlphaMultiplier = (float)colorTransformObject[ConstValues.A_ALPHA_MULTIPLIER] * 0.01f;
				frame.Color.RedMultiplier = (float)colorTransformObject[ConstValues.A_RED_MULTIPLIER] * 0.01f;
				frame.Color.GreenMultiplier = (float)colorTransformObject[ConstValues.A_GREEN_MULTIPLIER] * 0.01f;
				frame.Color.BlueMultiplier = (float)colorTransformObject[ConstValues.A_BLUE_MULTIPLIER] * 0.01f;
			}
			
			return frame;
		}
		
		private static void parseTransform(Dictionary<String, Object> transformObject, DBTransform transform, Point pivot = null)
		{
			if(transformObject!=null)
			{
				if(transform!=null)
				{
					transform.X = (float)transformObject[ConstValues.A_X];
					transform.Y = (float)transformObject[ConstValues.A_Y];
					transform.SkewX = (float)transformObject[ConstValues.A_SKEW_X] * ConstValues.ANGLE_TO_RADIAN;
					transform.SkewY = (float)transformObject[ConstValues.A_SKEW_Y] * ConstValues.ANGLE_TO_RADIAN;
					transform.ScaleX = (float)transformObject[ConstValues.A_SCALE_X];
					transform.ScaleY = (float)transformObject[ConstValues.A_SCALE_Y];

				}
				if(pivot!=null)
				{
					pivot.X = (float)transformObject[ConstValues.A_PIVOT_X];
					pivot.Y = (float)transformObject[ConstValues.A_PIVOT_Y];
				}
			}
		}
	}
}

