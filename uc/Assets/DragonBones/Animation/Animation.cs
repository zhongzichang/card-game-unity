// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using Com.Viperstudio.Utils;
using DragonBones.Objects;
using DragonBones.Events;
using Com.Viperstudio.Geom;
using System.Collections.Generic;

namespace DragonBones.Animation
{
	public class Animation
	{
		public const string NONE = "none";
		public const string SAME_LAYER = "sameLayer";
		public const string SAME_GROUP = "sameGroup";
		public const string SAME_LAYER_AND_GROUP = "sameLayerAndGroup";
		public const string ALL = "all";
		
		/**
		 * Whether animation tweening is enabled or not.
		 */
		public bool TweenEnabled;
		
		/** @private */

		public List<List<AnimationState>> _animationLayer;
		
		private Armature _armature;
		private bool _isActive;
		
		/**
		 * An vector containing all AnimationData names the Animation can play.
		 * @see dragonBones.objects.AnimationData.
		 */
		public List<string> MovementList
		{
			get { return _animationList; }
		}
		
		/**
		 * The name of the last AnimationData played.
		 * @see dragonBones.objects.AnimationData.
		 */
		public string MovementID
		{
			get { return _lastAnimationState!=null ? _lastAnimationState.Name : null; }
		}

		 /**
		  * @private
		  */
		public AnimationState _lastAnimationState;
		/**
		 * The last AnimationData this Animation played.
		 * @see dragonBones.objects.AnimationData.
		 */
		public AnimationState LastAnimationState
		{
			get { return _lastAnimationState; }
		}
		
		private List<string> _animationList;
		/**
		 * An vector containing all AnimationData names the Animation can play.
		 * @see dragonBones.objects.AnimationData.
		 */
		public List<string> AnimationList
		{
			get { return _animationList; }
		}
		
		private bool _isPlaying;
		public bool IsPlaying
		{
			get { return _isPlaying && _isActive; }
		}
		
		public bool IsComplete
		{
			get {
				if(_lastAnimationState!=null)
				{
					if(!_lastAnimationState.IsComplete)
					{
						return false;
					}
					int j = _animationLayer.Count;
					while(j -- >0)
					{
						List<AnimationState> animationStateList = _animationLayer[j];
						int i = animationStateList.Count;
						while(i -- >0)
						{
							if(!animationStateList[i].IsComplete)
							{
								return false;
							}
						}
					}
					return true;
				}
				return false;
			}
		}
		
		private List<AnimationData> _animationDataList;
		/**
		 * The AnimationData list associated with this Animation instance.
		 * @see dragonBones.objects.AnimationData.
		 */
		public List<AnimationData> AnimationDataList
		{
			get { return _animationDataList; }
			set {
					_animationDataList = value;
				    _animationList.Clear();
				    foreach(AnimationData animationData in _animationDataList)
					{
					_animationList.Add(animationData.Name);
					}
				}
		}

		
		private float _timeScale = 1f;
		/**
		 * The amount by which passed time should be scaled. Used to slow down or speed up animations. Defaults to 1.
		 */
		public float TimeScale
		{
			get { return _timeScale; }
			set {
					if (value < 0)
					{
						value = 0;
					}
					_timeScale = value;
				}
		}

		/**
		 * Creates a new Animation instance and attaches it to the passed Armature.
		 * @param	An Armature to attach this Animation instance to.
		 */
		public Animation(Armature armature)
		{
			_armature = armature;
			_animationLayer = new List<List<AnimationState>>();
			_animationList = new List<string>();
			
			_isPlaying = false;
			_isActive = false;
			TweenEnabled = true;
		}
		
		/**
		 * Qualifies all resources used by this Animation instance for garbage collection.
		 */
		public void Dispose()
		{
			if(_armature ==  null)
			{
				return;
			}
			Stop();
			int i = _animationLayer.Count;
			while(i -- >0)
			{
				List<AnimationState> animationStateList = _animationLayer[i];
				int j = animationStateList.Count;
				while(j -- >0)
				{
					AnimationState.returnObject(animationStateList[j]);
				}
				animationStateList.Clear();
			}
			_animationLayer.Clear();
		    _animationList.Clear();
			
			_armature = null;
			_animationLayer = null;
			_animationDataList = null;
			_animationList = null;
		}
		
		/**
		 * Move the playhead to that AnimationData
		 * @param animationName The name of the AnimationData to play.
		 * @param fadeInTime A fade time to apply (> 0)
		 * @param duration The duration of that AnimationData.
		 * @param loop Loop(0:loop forever, 1~+∞:loop times, -1~-∞:will fade animation after loop complete).
		 * @param layer The layer of the animation.
		 * @param group The group of the animation.
		 * @param fadeOutMode Fade out mode.
		 * @param displayControl Display control.
		 * @param pauseFadeOut Pause other animation playing.
		 * @param pauseFadeIn Pause this animation playing before fade in complete.
		 * @see dragonBones.objects.AnimationData.
		 * @see dragonBones.animation.AnimationState.
		 */
		public AnimationState GotoAndPlay(
			string animationName, 
			float fadeInTime = -1f, 
			float duration = -1f, 
			float loop = float.NaN, 
			uint layer = 0, 
			string group = null,
			string fadeOutMode = SAME_LAYER_AND_GROUP,
			bool displayControl = true,
			bool pauseFadeOut = true,
			bool pauseFadeIn = true
		)
		{
			if (_animationDataList==null)
			{
				return null;
			}
			int i = _animationDataList.Count;
			int j;
			AnimationData animationData = null;
			while(i -- >0)
			{
				if(_animationDataList[i].Name == animationName)
				{
					animationData = _animationDataList[i];
					break;
				}
			}
			if (animationData==null)
			{
				return null;
			}
			
			_isPlaying = true;

			fadeInTime = fadeInTime < 0?(animationData.FadeInTime < 0?0.3f:animationData.FadeInTime):fadeInTime;
			
			float durationScale;
			if(duration < 0)
			{
				durationScale = animationData.Scale < 0?1:animationData.Scale;
			}
			else
			{
				durationScale = duration / animationData.Duration;
			}
			
			loop = float.IsNaN(loop)?animationData.Loop:loop;
			layer = addLayer(layer);
			
			//autoSync = autoSync && !pauseFadeOut && !pauseFadeIn;
			AnimationState animationState;
			List<AnimationState> animationStateList;
			switch(fadeOutMode)
			{
			case NONE:
				break;
			case SAME_LAYER:
				animationStateList = _animationLayer[(int)layer];
				i = animationStateList.Count;
				while(i -- >0)
				{
					animationState = animationStateList[i];
					animationState.FadeOut(fadeInTime, pauseFadeOut);
				}
				break;
			case SAME_GROUP:
				j = _animationLayer.Count;
				while(j -- >0)
				{
					animationStateList = _animationLayer[j];
					i = animationStateList.Count;
					while(i -- >0)
					{
						animationState = animationStateList[i];
						if(animationState.Group == group)
						{
							animationState.FadeOut(fadeInTime, pauseFadeOut);
						}
					}
				}
				break;
			case ALL:
			    j = _animationLayer.Count;
				while(j -- >0)
				{
					animationStateList = _animationLayer[j];
					i = animationStateList.Count;
					while(i -- >0)
					{
						animationState = animationStateList[i];
						animationState.FadeOut(fadeInTime, pauseFadeOut);
					}
				}
				break;
			case SAME_LAYER_AND_GROUP:
			default:
				animationStateList = _animationLayer[(int)layer];
				i = animationStateList.Count;
				while(i -- >0)
				{
					animationState = animationStateList[i];
					if(animationState.Group == group)
					{
						animationState.FadeOut(fadeInTime, pauseFadeOut);
					}
				}

				break;
			}

			_lastAnimationState = AnimationState.borrowObject();
			_lastAnimationState.Group = group;
			_lastAnimationState.TweenEnabled = TweenEnabled;
			_lastAnimationState.fadeIn(_armature, animationData, fadeInTime, 1 / durationScale, (int)loop, layer, displayControl, pauseFadeIn);
			
			addState(_lastAnimationState);
			
			List<Slot> slotList = _armature._slotList;
			Slot slot;
			i = slotList.Count;
			while(i -- >0)
			{
				slot = slotList[i];
				if(slot.ChildArmature!=null)
				{
					slot.ChildArmature.Animation.GotoAndPlay(animationName, fadeInTime);
				}
			}
			
			_lastAnimationState.AdvanceTime(0);
			
			return _lastAnimationState;
		}
		
		/**
		 * Play the animation from the current position.
		 */
		public void Play()
		{
			if (_animationDataList==null || _animationDataList.Count == 0)
			{
				return;
			}
			if(_lastAnimationState == null)
			{
				GotoAndPlay(_animationDataList[0].Name);
			}
			else if (!_isPlaying)
			{
				_isPlaying = true;
			}
			else
			{
				GotoAndPlay(_lastAnimationState.Name);
			}
		}
		
		public void Stop()
		{
			_isPlaying = false;
		}
		
		/**
		 * Returns the AnimationState named name.
		 * @return A AnimationState instance.
		 * @see dragonBones.animation.AnimationState.
		 */
		public AnimationState getState(string name, uint layer = 0)
		{
			int l = _animationLayer.Count;
			if(l == 0)
			{
				return null;
			}
			else if(layer >= l)
			{
				layer = (uint)(l - 1);
			}
			
			List<AnimationState> animationStateList = _animationLayer[(int)layer];
			if(animationStateList == null)
			{
				return null;
			}
			int i = animationStateList.Count;
			while(i -- >0)
			{
				if(animationStateList[i].Name == name)
				{
					return animationStateList[i];
				}
			}
			
			return null;
		}
		
		public bool HasAnimation(string animationName)
		{
			int i = _animationDataList.Count;
			while(i -- >0)
			{
				if(_animationDataList[i].Name == animationName)
				{
					return true;
				}
			}
			
			return false;
		}
		
		public void AdvanceTime(float passedTime)
		{
			/*
			if(!_isPlaying || !_isActive)
			{
				return;
			}
			*/
			
			passedTime *= _timeScale;
			
			int l = _armature._boneList.Count;
			int i;
			int j;
			int k = l;
			uint stateListLength;
			Bone bone;
			string boneName;
			float weigthLeft;
			
			float x;
			float y;
			float skewX;
			float skewY;
			float scaleX;
			float scaleY;
			float pivotX;
			float pivotY;
			
			float layerTotalWeight;
			List<AnimationState> animationStateList;
			AnimationState animationState;
			TimelineState timelineState;
			float weight;
			DBTransform transform;
			Point pivot;
			
			l --;
			while(k -- >0)
			{
				bone = _armature._boneList[k];
				boneName = bone.Name;
				weigthLeft = 1f;
				
				x = 0f;
				y = 0f;
				skewX = 0f;
				skewY = 0f;
				scaleX = 0f;
				scaleY = 0f;
				pivotX = 0f;
				pivotY = 0f;
				
				i = _animationLayer.Count;

				while(i -- >0)
				{
					layerTotalWeight = 0f;
					animationStateList = _animationLayer[i];
					stateListLength = (uint)animationStateList.Count;

					for(j = 0;j < stateListLength;j ++)
					{
						animationState = animationStateList[j];
						if(k == l)
						{

							if(animationState.AdvanceTime(passedTime))
							{
								removeState(animationState);
								j --;
								stateListLength --;
								continue;
							}

						}
						
						timelineState = animationState._timelineStates[boneName];
						
						if(timelineState != null&& timelineState.TweenActive)
						{
							weight = animationState._fadeWeight * animationState.Weight * weigthLeft;
							transform = timelineState.Transform;
							pivot = timelineState.Pivot;
							x += transform.X * weight;
							y += transform.Y * weight;
							skewX += transform.SkewX * weight;
							skewY += transform.SkewY * weight;
							scaleX += transform.ScaleX * weight;
							scaleY += transform.ScaleY * weight;
							pivotX += pivot.X * weight;
							pivotY += pivot.Y * weight;
							
							layerTotalWeight += weight;
						}
					}

					if(layerTotalWeight >= weigthLeft)
					{
						break;
					}
					else
					{
						weigthLeft -= layerTotalWeight;
					}
				}
				transform = bone._tween;
				pivot = bone._tweenPivot;
				
				transform.X = x;
				transform.Y = y;
				transform.SkewX = skewX;
				transform.SkewY = skewY;
				transform.ScaleX = scaleX;
				transform.ScaleY = scaleY;
				pivot.X = pivotX;
				pivot.Y = pivotY;
			}
			
		}
		
		/** @private */
		public void setActive(AnimationState animationState, bool active)
		{
			if(active)
			{
				_isActive = true;
			}
			else
			{
				int i = _animationLayer.Count;
				int j;
				List<AnimationState> animationStateList;
				while(i -- >0)
				{
					animationStateList = _animationLayer[i];
					j = animationStateList.Count;
					while(j -- >0)
					{
						if(animationStateList[j].IsPlaying)
						{
							return;
						}
					}
				}
				_isActive = false;
			}
		}
		
		private uint addLayer(uint layer)
		{
			if(layer >= _animationLayer.Count)
			{
				layer = (uint)_animationLayer.Count;
				_animationLayer.Add( new List<AnimationState>());
			}
			return layer;
		}
		
		private void addState(AnimationState animationState)
		{
			List<AnimationState> animationStateList = _animationLayer[(int)animationState.Layer];
			animationStateList.Add(animationState);
		}
		
		private void removeState(AnimationState animationState)
		{
			int layer = (int)animationState.Layer;
			List<AnimationState> animationStateList = _animationLayer[layer];
			animationStateList.RemoveAt(animationStateList.IndexOf(animationState));
			
			AnimationState.returnObject(animationState);
			
			if(animationStateList.Count == 0 && layer == _animationLayer.Count - 1)
			{
				_animationLayer.RemoveAt(_animationLayer.Count-1);
			}
		}


	}
}

